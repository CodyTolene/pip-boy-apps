// ====== Flappy-ish game ======
// ====== A learning experience for Jim D. ======
// ====== Left Knob-press / Radio Knob-press flaps/flies, Torch pauses, Power exits ======

var C = (typeof bC !== "undefined") ? bC : g;

const Storage = require("Storage");
const HS_KEY = "flappy_hs";
let highScore = Storage.readJSON(HS_KEY, 1) || 0;

let paused = false;
let menuItems = ["RESUME", "RESTART", "EXIT TO APPS"];
let menuIndex = 0;
let W = C.getWidth();
let H = C.getHeight();
let finalScore = 0;
let lastRunReason = "";
let bird, pipes, score, gameOver;
let loopId = null;
let flapWatchId = null;
let powerWatchId = null;
let showingScoreScreen = false;
let playWasDown = false;

const GRAVITY = 0.5;
const FLAP = -6;
const PIPE_SPEED = 2;
const PIPE_GAP = 40;
const PIPE_WIDTH = 16;

function flapAction() {
  if (showingScoreScreen) return;   // if you have this flag
  if (paused && !gameOver) return;  // ignore while in pause menu

  if (gameOver) resetGame();
  else bird.vy = FLAP;
}

function saveHighScoreIfNeeded(s) {
  if (s > highScore) {
    highScore = s;
    Storage.writeJSON(HS_KEY, highScore);
  }
}

function togglePause() {
  paused = !paused;
  if (paused) menuIndex = 0;
}

function exitToApps() {
  stopGame();
  if (global.Pip) Pip.removeAllListeners();

  if (typeof submenuApps === "function") submenuApps();
  else if (typeof showMainMenu === "function") showMainMenu();
  else {
    C.clear();
    C.setFont("6x8", 2);
    C.setFontAlign(-1, -1);
    drawCentered("Exited", Math.floor(H * 0.45));
    flushScreen();
  }
}

let scoreExitArmed = false;

function showScoreThenExit() {
  showingScoreScreen = true;
  scoreExitArmed = true;

  function drawScoreScreen() {
    C.clear();
    C.setFontAlign(-1, -1);

    C.setFont("6x8", 2);
    drawCentered("FINAL SCORE", Math.floor(H * 0.22));

    C.setFont("6x8", 2);
    drawCentered("" + finalScore, Math.floor(H * 0.42));

    C.setFont("6x8", 1);
    drawCentered("High: " + highScore, Math.floor(H * 0.56));
    drawCentered("Knob1/Torch: continue", Math.floor(H * 0.74));

    flushScreen();
  }

  drawScoreScreen();

  Pip.removeAllListeners();

  function go() {
    if (!scoreExitArmed) return;
    scoreExitArmed = false;
    showingScoreScreen = false;   // <-- important
    exitToApps();
  }

  Pip.on("knob1", val => { if (val === 0) go(); });
  Pip.on("torch", () => go());
}

function flushScreen() {
  if (C && C.flip) return C.flip();
  if (C && C.flush) return C.flush();
  if (C && C.update) return C.update();
  if (global.LCD && LCD.flip) return LCD.flip();
}

function newPipe() {
  let gap = Math.min(PIPE_GAP, H - 30);
  let margin = 10;
  let usable = H - gap - margin*2;
  let gapY = margin + Math.random() * (usable > 0 ? usable : 1);
  pipes.push({ x: W, gapY: gapY, scored: false, gap: gap });
}

function resetGame() {
  W = C.getWidth();
  H = C.getHeight();
  paused = false;

  bird = { x: Math.floor(W * 0.25), y: H / 2, vy: 0, size: 6 };
  pipes = [];
  score = 0;
  gameOver = false;

  newPipe();
}

function update() {
  if (showingScoreScreen) return;

  // Right-hand RADIO PLAY button (edge-triggered)
  if (typeof BTN_PLAY !== "undefined") {
    let down = BTN_PLAY.read();
    if (down && !playWasDown) flapAction();
    playWasDown = down;
  }

  if (gameOver || paused) return;

  bird.vy += GRAVITY;
  bird.y += bird.vy;

  if (!isFinite(bird.y)) { bird.y = H/2; bird.vy = 0; }

  if (bird.y < 0 || bird.y + bird.size > H) endRun("FELL");

  for (let i = 0; i < pipes.length; i++) {
    let p = pipes[i];
    p.x -= PIPE_SPEED;

    if (bird.x + bird.size > p.x && bird.x < p.x + PIPE_WIDTH) {
      if (bird.y < p.gapY || bird.y + bird.size > p.gapY + p.gap) endRun("HIT");
    }

    if (!p.scored && p.x + PIPE_WIDTH < bird.x) {
      p.scored = true;
      score++;
    }
  }

  if (pipes.length && pipes[0].x < -PIPE_WIDTH) {
    pipes.shift();
    newPipe();
  }
}

function drawCentered(text, y) {
  C.setFontAlign(-1, -1); // left/top
  let tw = C.stringWidth(text);
  let x = Math.max(0, Math.floor((W - tw) / 2));
  C.drawString(text, x, y);
}

function draw() {
  if (showingScoreScreen) return;
  C.clear();

  // Pipes
  for (let i = 0; i < pipes.length; i++) {
    let p = pipes[i];
    C.fillRect(p.x, 0, p.x + PIPE_WIDTH, p.gapY);
    C.fillRect(p.x, p.gapY + p.gap, p.x + PIPE_WIDTH, H);
  }

  // Bird
  C.fillRect(bird.x, bird.y, bird.x + bird.size, bird.y + bird.size);

  // Score
  C.setFont("6x8", 2);
  C.setFontAlign(-1, -1);
  C.drawString("S:" + score, 2, 2);

  if (gameOver) {

      C.setFont("6x8", 2);
      drawCentered("GAME OVER", Math.floor(H * 0.28));

      C.setFont("6x8", 1.5);
        drawCentered("Score: " + finalScore, Math.floor(H * 0.46));
        drawCentered("Highest Score: " + highScore, Math.floor(H * 0.58));

      drawCentered("Knob1 to Restart", Math.floor(H * 0.66));
      drawCentered("Power to Exit", Math.floor(H * 0.74));

  } else if (paused) {
    drawPauseMenu();
  }

  flushScreen();
}

let lastInput = "none";

function bindGameControls() {
  Pip.removeAllListeners();

   Pip.on("torch", () => {
     if (!gameOver && typeof togglePause === "function") togglePause();
  });

  Pip.on("knob1", val => {
    if (paused && !gameOver) {
      if (val === 0) {
        // select
        let choice = menuItems[menuIndex];
        if (choice === "RESUME") paused = false;
        else if (choice === "RESTART") { paused = false; resetGame(); }
        else if (choice === "EXIT TO APPS") {
          finalScore = score;
          saveHighScoreIfNeeded(finalScore);
          showScoreThenExit();
        }
      } else if (val > 0) {
        menuIndex = (menuIndex + 1) % menuItems.length;
      } else if (val < 0) {
        menuIndex = (menuIndex + menuItems.length - 1) % menuItems.length;
      }
      return;
    }

    if (val === 0) {
      if (gameOver) resetGame();
      else bird.vy = FLAP;
    }
  });
}

function drawPauseMenu() {
  C.setFontAlign(-1, -1);
  C.drawRect(10, 20, W - 10, H - 20);

  C.setFont("6x8", 2);
  drawCentered("PAUSED", 28);

  C.setFont("6x8", 1);
  for (let i = 0; i < menuItems.length; i++) {
    let y = 52 + i * 12;
    let t = (i === menuIndex ? "> " : "  ") + menuItems[i];
    drawCentered(t, y);
  }

  C.setFont("6x8", 1);
  drawCentered("Torch: pause/resume", H - 24);
}

function stopGame() {
  if (loopId) { clearInterval(loopId); loopId = null; }
  if (powerWatchId) { clearWatch(powerWatchId); powerWatchId = null; }
  if (global.Pip) Pip.removeAllListeners();
}

function endRun(reason) {
  gameOver = true;
  paused = false;
  finalScore = score;
  saveHighScoreIfNeeded(finalScore);
  lastRunReason = reason || "";
  draw();
}

function startGame() {
  stopGame();

  resetGame();
  bindGameControls();
  draw();

powerWatchId = setWatch(() => {
  saveHighScoreIfNeeded(score);
  E.reboot();
}, BTN_POWER, { repeat: true, edge: "rising", debounce: 50 });

  loopId = setInterval(() => {
    update();
    draw();
  }, 50);
}

startGame();
